/**
 * Copyright (c) 2021 Artem Hlumov <artyom.altair@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * ==================================== FAST FOURIER TRANSFORMATION ====================================
 *
 * The file contains implementation of sequential Cooleyâ€“Tukey algorithm for
 * computation of Fourier Transformation. Implementation focused on computation speed by having
 * pre-calculated table of roots of unity, so sacrifying memory. It means the algorithm has
 * limited amount of array sizes to process, in particular: 2, 4, 8, 16, 32, 64, 128, 256.
 * This also makes possible to define fast versions of pow2(), log2() and inv_sqrt() functions
 * with pre-calculated values. Also since we focus on speed, there is no sanity checks, so
 * invoking fft() with unexpected parameters will lead to undefined behaviour.
 * In order to extend the algorithm to bigger arrays, two steps should be done:
 * 1) Function reverse_bits() should be reworked to take something bigger than one byte.
 * 2) Array roots should be regenerated using the following code:
 *
 *     const int SIZE = 512; // Put desired size here, note that it should be a power of 2.
 *     for (int i = 0; i < SIZE; i++) {
 *         std::cout << std::setprecision(15) << "{" << std::cos(2 * M_PI * i / SIZE) << ", " << std::sin(2 * M_PI * i / SIZE) << "}, ";
 *     }
 *
 * =====================================================================================================
 */

#pragma once

#include <complex>

/**
 * Represent the value as bitSize-bit number and reverse bits.
 * We use https://graphics.stanford.edu/~seander/bithacks.html#ReverseByteWith32Bits to reverse bits in one single byte
 * and then trim it to the desired size using right shift.
 * @param value Value to reverse. Should be less than pow(2, bitSize).
 * @param bitSize Size of then number in bits. Should be <= 8.
 * @return Number with reversed bits assuming the number has bitSize bits.
 */
constexpr inline unsigned char reverse_bits(unsigned char value, int bitSize) {
    return (((value * 0x0802LU & 0x22110LU) | (value * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16) >> (8 - bitSize);
}

/**
 * Fast function to calculate pow(2, exponent) for the predefined set of values used in the algorithm.
 * @param value Exponent value (should be in range [1, 8]).
 * @return Value of pow(2, exponent).
 */
constexpr inline int pow2(int exponent) {
    switch(exponent) {
    case 1:
        return 2;
    case 2:
        return 4;
    case 3:
        return 8;
    case 4:
        return 16;
    case 5:
        return 32;
    case 6:
        return 64;
    case 7:
        return 128;
    case 8:
        return 256;
    default:
        return -1;
    }
}

/**
 * Fast function to calculate binary logarithm for the predefined set of values used in the algorithm.
 * @param value Value to use for log calculation. Should be a power of 2 in range [2, 256].
 * @return Binary logarithm of the given value.
 */
constexpr inline int log2(int value) {
    switch(value) {
    case 2:
        return 1;
    case 4:
        return 2;
    case 8:
        return 3;
    case 16:
        return 4;
    case 32:
        return 5;
    case 64:
        return 6;
    case 128:
        return 7;
    case 256:
        return 8;
    default:
        return -1;
    }
}

/**
 * Fast function to calculate 1.0 / sqrt(value) for the predefined set of values used in the algorithm.
 * @param value Value to use for the calculation.
 * @return 1.0 / sqrt(value)
 */
constexpr inline double inv_sqrt(int value) {
    switch(value) {
    case 2:
        return 0.7071067811865475;
    case 4:
        return 0.5;
    case 8:
        return 0.3535533905932737;
    case 16:
        return 0.25;
    case 32:
        return 0.1767766952966369;
    case 64:
        return 0.125;
    case 128:
        return 0.08838834764831843;
    case 256:
        return 0.0625;
    default:
        return -1;
    }
}

/**
 * Contans 256 root of unity of degree 256.
 * The roots are calculated in the counterclockwise order starting from 1, so roots[0] == pow(w, 256) and roots[255] == pow(w, 1).
 */
std::complex<double> roots[] = {{1, 0}, {0.999698818696204, 0.0245412285229123}, {0.998795456205172, 0.049067674327418}, {0.99729045667869, 0.0735645635996674}, {0.995184726672197, 0.0980171403295606}, {0.99247953459871, 0.122410675199216}, {0.989176509964781, 0.146730474455362}, {0.985277642388941, 0.170961888760301}, {0.98078528040323, 0.195090322016128}, {0.975702130038529, 0.21910124015687}, {0.970031253194544, 0.242980179903264}, {0.96377606579544, 0.266712757474898}, {0.956940335732209, 0.290284677254462}, {0.949528180593037, 0.313681740398892}, {0.941544065183021, 0.33688985339222}, {0.932992798834739, 0.359895036534988}, {0.923879532511287, 0.38268343236509}, {0.914209755703531, 0.40524131400499}, {0.903989293123443, 0.427555093430282}, {0.893224301195515, 0.449611329654607}, {0.881921264348355, 0.471396736825998}, {0.870086991108711, 0.492898192229784}, {0.857728610000272, 0.514102744193222}, {0.844853565249707, 0.534997619887097}, {0.831469612302545, 0.555570233019602}, {0.817584813151584, 0.575808191417845}, {0.803207531480645, 0.595699304492433}, {0.788346427626606, 0.615231590580627}, {0.773010453362737, 0.634393284163645}, {0.757208846506485, 0.653172842953777}, {0.740951125354959, 0.671558954847018}, {0.724247082951467, 0.689540544737067}, {0.707106781186548, 0.707106781186547}, {0.689540544737067, 0.724247082951467}, {0.671558954847018, 0.740951125354959}, {0.653172842953777, 0.757208846506484}, {0.634393284163645, 0.773010453362737}, {0.615231590580627, 0.788346427626606}, {0.595699304492433, 0.803207531480645}, {0.575808191417845, 0.817584813151584}, {0.555570233019602, 0.831469612302545}, {0.534997619887097, 0.844853565249707}, {0.514102744193222, 0.857728610000272}, {0.492898192229784, 0.870086991108711}, {0.471396736825998, 0.881921264348355}, {0.449611329654607, 0.893224301195515}, {0.427555093430282, 0.903989293123443}, {0.40524131400499, 0.914209755703531}, {0.38268343236509, 0.923879532511287}, {0.359895036534988, 0.932992798834739}, {0.33688985339222, 0.941544065183021}, {0.313681740398892, 0.949528180593037}, {0.290284677254462, 0.956940335732209}, {0.266712757474898, 0.96377606579544}, {0.242980179903264, 0.970031253194544}, {0.21910124015687, 0.975702130038529}, {0.195090322016128, 0.98078528040323}, {0.170961888760301, 0.985277642388941}, {0.146730474455362, 0.989176509964781}, {0.122410675199216, 0.99247953459871}, {0.0980171403295608, 0.995184726672197}, {0.0735645635996675, 0.99729045667869}, {0.0490676743274181, 0.998795456205172}, {0.0245412285229123, 0.999698818696204}, {6.12303176911189e-17, 1}, {-0.0245412285229121, 0.999698818696204}, {-0.049067674327418, 0.998795456205172}, {-0.0735645635996673, 0.99729045667869}, {-0.0980171403295606, 0.995184726672197}, {-0.122410675199216, 0.99247953459871}, {-0.146730474455362, 0.989176509964781}, {-0.170961888760301, 0.985277642388941}, {-0.195090322016128, 0.98078528040323}, {-0.21910124015687, 0.975702130038529}, {-0.242980179903264, 0.970031253194544}, {-0.266712757474898, 0.96377606579544}, {-0.290284677254462, 0.956940335732209}, {-0.313681740398891, 0.949528180593037}, {-0.33688985339222, 0.941544065183021}, {-0.359895036534988, 0.932992798834739}, {-0.38268343236509, 0.923879532511287}, {-0.40524131400499, 0.914209755703531}, {-0.427555093430282, 0.903989293123443}, {-0.449611329654607, 0.893224301195515}, {-0.471396736825998, 0.881921264348355}, {-0.492898192229784, 0.870086991108711}, {-0.514102744193222, 0.857728610000272}, {-0.534997619887097, 0.844853565249707}, {-0.555570233019602, 0.831469612302545}, {-0.575808191417845, 0.817584813151584}, {-0.595699304492433, 0.803207531480645}, {-0.615231590580627, 0.788346427626606}, {-0.634393284163645, 0.773010453362737}, {-0.653172842953777, 0.757208846506485}, {-0.671558954847018, 0.740951125354959}, {-0.689540544737067, 0.724247082951467}, {-0.707106781186547, 0.707106781186548}, {-0.724247082951467, 0.689540544737067}, {-0.740951125354959, 0.671558954847019}, {-0.757208846506485, 0.653172842953777}, {-0.773010453362737, 0.634393284163645}, {-0.788346427626606, 0.615231590580627}, {-0.803207531480645, 0.595699304492433}, {-0.817584813151584, 0.575808191417845}, {-0.831469612302545, 0.555570233019602}, {-0.844853565249707, 0.534997619887097}, {-0.857728610000272, 0.514102744193222}, {-0.870086991108711, 0.492898192229784}, {-0.881921264348355, 0.471396736825998}, {-0.893224301195515, 0.449611329654607}, {-0.903989293123443, 0.427555093430282}, {-0.914209755703531, 0.40524131400499}, {-0.923879532511287, 0.38268343236509}, {-0.932992798834739, 0.359895036534988}, {-0.941544065183021, 0.33688985339222}, {-0.949528180593037, 0.313681740398891}, {-0.956940335732209, 0.290284677254462}, {-0.96377606579544, 0.266712757474898}, {-0.970031253194544, 0.242980179903264}, {-0.975702130038528, 0.21910124015687}, {-0.98078528040323, 0.195090322016129}, {-0.985277642388941, 0.170961888760301}, {-0.989176509964781, 0.146730474455362}, {-0.99247953459871, 0.122410675199216}, {-0.995184726672197, 0.0980171403295608}, {-0.99729045667869, 0.0735645635996677}, {-0.998795456205172, 0.049067674327418}, {-0.999698818696204, 0.0245412285229123}, {-1, 1.22460635382238e-16}, {-0.999698818696204, -0.0245412285229121}, {-0.998795456205172, -0.0490676743274177}, {-0.99729045667869, -0.0735645635996675}, {-0.995184726672197, -0.0980171403295606}, {-0.99247953459871, -0.122410675199216}, {-0.989176509964781, -0.146730474455362}, {-0.985277642388941, -0.170961888760301}, {-0.98078528040323, -0.195090322016128}, {-0.975702130038529, -0.21910124015687}, {-0.970031253194544, -0.242980179903264}, {-0.96377606579544, -0.266712757474898}, {-0.956940335732209, -0.290284677254462}, {-0.949528180593037, -0.313681740398891}, {-0.941544065183021, -0.33688985339222}, {-0.932992798834739, -0.359895036534988}, {-0.923879532511287, -0.38268343236509}, {-0.914209755703531, -0.40524131400499}, {-0.903989293123443, -0.427555093430282}, {-0.893224301195515, -0.449611329654607}, {-0.881921264348355, -0.471396736825998}, {-0.870086991108711, -0.492898192229784}, {-0.857728610000272, -0.514102744193222}, {-0.844853565249707, -0.534997619887097}, {-0.831469612302545, -0.555570233019602}, {-0.817584813151584, -0.575808191417845}, {-0.803207531480645, -0.595699304492433}, {-0.788346427626606, -0.615231590580627}, {-0.773010453362737, -0.634393284163645}, {-0.757208846506485, -0.653172842953777}, {-0.740951125354959, -0.671558954847018}, {-0.724247082951467, -0.689540544737067}, {-0.707106781186548, -0.707106781186547}, {-0.689540544737067, -0.724247082951467}, {-0.671558954847019, -0.740951125354959}, {-0.653172842953777, -0.757208846506484}, {-0.634393284163646, -0.773010453362737}, {-0.615231590580627, -0.788346427626606}, {-0.595699304492433, -0.803207531480645}, {-0.575808191417845, -0.817584813151584}, {-0.555570233019602, -0.831469612302545}, {-0.534997619887097, -0.844853565249707}, {-0.514102744193222, -0.857728610000272}, {-0.492898192229784, -0.870086991108711}, {-0.471396736825998, -0.881921264348355}, {-0.449611329654607, -0.893224301195515}, {-0.427555093430282, -0.903989293123443}, {-0.40524131400499, -0.91420975570353}, {-0.38268343236509, -0.923879532511287}, {-0.359895036534988, -0.932992798834739}, {-0.33688985339222, -0.941544065183021}, {-0.313681740398891, -0.949528180593037}, {-0.290284677254462, -0.956940335732209}, {-0.266712757474899, -0.96377606579544}, {-0.242980179903264, -0.970031253194544}, {-0.21910124015687, -0.975702130038528}, {-0.195090322016129, -0.98078528040323}, {-0.170961888760302, -0.985277642388941}, {-0.146730474455362, -0.989176509964781}, {-0.122410675199216, -0.99247953459871}, {-0.0980171403295605, -0.995184726672197}, {-0.0735645635996674, -0.99729045667869}, {-0.049067674327418, -0.998795456205172}, {-0.0245412285229124, -0.999698818696204}, {-1.83690953073357e-16, -1}, {0.024541228522912, -0.999698818696204}, {0.0490676743274177, -0.998795456205172}, {0.073564563599667, -0.99729045667869}, {0.0980171403295601, -0.995184726672197}, {0.122410675199216, -0.99247953459871}, {0.146730474455362, -0.989176509964781}, {0.170961888760301, -0.985277642388941}, {0.195090322016128, -0.98078528040323}, {0.21910124015687, -0.975702130038529}, {0.242980179903264, -0.970031253194544}, {0.266712757474898, -0.96377606579544}, {0.290284677254462, -0.956940335732209}, {0.313681740398891, -0.949528180593037}, {0.33688985339222, -0.941544065183021}, {0.359895036534988, -0.932992798834739}, {0.38268343236509, -0.923879532511287}, {0.40524131400499, -0.914209755703531}, {0.427555093430282, -0.903989293123443}, {0.449611329654607, -0.893224301195515}, {0.471396736825998, -0.881921264348355}, {0.492898192229784, -0.870086991108711}, {0.514102744193222, -0.857728610000272}, {0.534997619887097, -0.844853565249707}, {0.555570233019602, -0.831469612302545}, {0.575808191417845, -0.817584813151584}, {0.595699304492433, -0.803207531480645}, {0.615231590580627, -0.788346427626606}, {0.634393284163646, -0.773010453362737}, {0.653172842953777, -0.757208846506485}, {0.671558954847018, -0.740951125354959}, {0.689540544737067, -0.724247082951467}, {0.707106781186547, -0.707106781186548}, {0.724247082951467, -0.689540544737067}, {0.740951125354959, -0.671558954847019}, {0.757208846506484, -0.653172842953777}, {0.773010453362737, -0.634393284163646}, {0.788346427626606, -0.615231590580627}, {0.803207531480645, -0.595699304492433}, {0.817584813151584, -0.575808191417845}, {0.831469612302545, -0.555570233019602}, {0.844853565249707, -0.534997619887097}, {0.857728610000272, -0.514102744193222}, {0.870086991108711, -0.492898192229784}, {0.881921264348355, -0.471396736825998}, {0.893224301195515, -0.449611329654607}, {0.903989293123443, -0.427555093430283}, {0.91420975570353, -0.40524131400499}, {0.923879532511287, -0.38268343236509}, {0.932992798834739, -0.359895036534988}, {0.941544065183021, -0.33688985339222}, {0.949528180593037, -0.313681740398892}, {0.956940335732209, -0.290284677254462}, {0.96377606579544, -0.266712757474899}, {0.970031253194544, -0.242980179903264}, {0.975702130038528, -0.21910124015687}, {0.98078528040323, -0.195090322016129}, {0.985277642388941, -0.170961888760302}, {0.989176509964781, -0.146730474455362}, {0.99247953459871, -0.122410675199216}, {0.995184726672197, -0.0980171403295605}, {0.99729045667869, -0.0735645635996674}, {0.998795456205172, -0.0490676743274181}, {0.999698818696204, -0.0245412285229124}};

/**
 * Calculate Fast Fourier Transformation of the input array having the given length.
 * Computations are done in place.
 * @param input Input array of size length. After the function finises, it will contain output values.
 * @param length Length of the input array. Should be one of 2, 4, 8, 16, 32, 64, 128, 256.
 */
void fft(std::complex<double>* input, int length)
{
    // How many times we need to process chunks.
    int logLengh = log2(length);
    // Roots of unity of degree 256 contain all roots of smaller degree, but they are
    // rarefied with stride 256 / length. This allows us to keep only one array of roots.
    const int stride = 256 >> logLengh;
    // Re-order the input array in reverse-bit order.
    for (int i = 0; i < length; i++) {
        int index = reverse_bits(i, logLengh);
        // If we only swap items after the current position, we can avoid problem
        // of double swapping and at the end all elements will be sorted in reverse-bit order.
        if (i < index) {
            std::complex<double> temp = input[index];
            input[index] = input[i];
            input[i] = temp;
        }
    }
    // Execute log2(length) steps increasing the chunk size from 2 to length.
    for (int i = 1; i <= logLengh; i++) {
        int m = pow2(i);
        // Process every chunk.
        for (int j = 0; j < length; j += m) {
            // Do the butterfly step between the first half of the chunk and the last half.
            for (int k = 0; k < m / 2; k++) {
                int u_index = j + k + m / 2;
                int v_index = j + k;
                std::complex<double> u = roots[length / m * k * stride] * input[u_index];
                std::complex<double> v = input[v_index];
                input[v_index] = v + u;
                input[u_index] = v - u;
            }
        }
    }
    // Normalize the output dividing it by sqrt(length).
    // As we have a fixed amount of lengths we can precalculate these values.
    for (int i = 0; i < length; i++) {
        input[i] *= inv_sqrt(length);
    }
}
